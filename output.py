
// Copyright (c) 2012 Leonhard Gruenschloss (leonhard@gruenschloss.org)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This file is automatically generated.

#ifndef __BRAY_HALTON_SAMPLER_H__
#define __BRAY_HALTON_SAMPLER_H__

#include <algorithm>
#include <vector>

// Compute points of the Halton sequence with with digit-permutations for different bases.
class Halton_sampler
{
public:
    // Init the permutation arrays using Faure-permutations. Alternatively, init_random can be
    // called before the sampling functionality can be used.
    void init_faure();

    // Init the permutation arrays using randomized permutations. Alternatively, init_faure can be
    // called before the sampling functionality can be used. The client needs to specify a random
    // number generator function object that can be used to generate a random sequence of integers.
    // That is: if f is a random number generator and N is a positive integer, then f(N) will
    // return an integer less than N and greater than or equal to 0.
    template <typename Random_number_generator>
    void init_random(Random_number_generator& rand);

    // Return the number of supported dimensions.
    static unsigned get_num_dimensions() { return 3u; }

    // Return the Halton sample for the given dimension (component) and index.
    // The client must have called init_random or init_faure at least once before.
    // dimension must be smaller than the value returned by get_num_dimensions().
    float sample(unsigned dimension, unsigned index) const;

private:
    static unsigned short invert(unsigned short base, unsigned short digits,
        unsigned short index, const std::vector<unsigned short>& perm);

    void init_tables(const std::vector<std::vector<unsigned short> >& perms);

    float halton2(unsigned index) const;
    float halton3(unsigned index) const;
    float halton5(unsigned index) const;

    unsigned short m_perm3[243];
    unsigned short m_perm5[125];
};

inline void Halton_sampler::init_faure()
{
    const unsigned max_base = 5u;
    std::vector<std::vector<unsigned short> > perms(max_base + 1);
    for (unsigned k = 1; k <= 3; ++k) // Keep identity permutations for base 1, 2, 3.
    {
        perms[k].resize(k);
        for (unsigned i = 0; i < k; ++i)
            perms[k][i] = i;
    }
    for (unsigned base = 4; base <= max_base; ++base)
    {
        perms[base].resize(base);
        const unsigned b = base / 2;
        if (base & 1) // odd
        {
            for (unsigned i = 0; i < base - 1; ++i)
                perms[base][i + (i >= b)] = perms[base - 1][i] + (perms[base - 1][i] >= b);
            perms[base][b] = b;
        }
        else // even
        {
            for (unsigned i = 0; i < b; ++i)
            {
                perms[base][i] = 2 * perms[b][i];
                perms[base][b + i] = 2 * perms[b][i] + 1;
            }
        }
    }
    init_tables(perms);
}

template <typename Random_number_generator>
void Halton_sampler::init_random(Random_number_generator& rand)
{
    const unsigned max_base = 5u;
    std::vector<std::vector<unsigned short> > perms(max_base + 1);
    for (unsigned k = 1; k <= 3; ++k) // Keep identity permutations for base 1, 2, 3.
    {
        perms[k].resize(k);
        for (unsigned i = 0; i < k; ++i)
            perms[k][i] = i;
    }
    for (unsigned base = 4; base <= max_base; ++base)
    {
        perms[base].resize(base);
        for (unsigned i = 0; i < base; ++i)
            perms[base][i] = i;
        std::random_shuffle(perms[base].begin(), perms[base].end(), rand);
    }
    init_tables(perms);
}

inline float Halton_sampler::sample(const unsigned dimension, const unsigned index) const
{
    switch (dimension)
    {
        case 0: return halton2(index);
        case 1: return halton3(index);
        case 2: return halton5(index);
    }
    return 0.f;
}

inline unsigned short Halton_sampler::invert(const unsigned short base, const unsigned short digits,
    unsigned short index, const std::vector<unsigned short>& perm)
{
    unsigned short result = 0;
    for (unsigned short i = 0; i < digits; ++i)
    {
        result = result * base + perm[index % base];
        index /= base;
    }
    return result;
}

inline void Halton_sampler::init_tables(const std::vector<std::vector<unsigned short> >& perms)
{
    for (unsigned short i = 0; i < 243; ++i)
        m_perm3[i] = invert(3, 5, i, perms[3]);
    for (unsigned short i = 0; i < 125; ++i)
        m_perm5[i] = invert(5, 3, i, perms[5]);
}

// Special case: radical inverse in base 2, with direct bit reversal.
inline float Halton_sampler::halton2(unsigned index) const
{
    index = (index << 16) | (index >> 16);
    index = ((index & 0x00ff00ff) << 8) | ((index & 0xff00ff00) >> 8);
    index = ((index & 0x0f0f0f0f) << 4) | ((index & 0xf0f0f0f0) >> 4);
    index = ((index & 0x33333333) << 2) | ((index & 0xcccccccc) >> 2);
    index = ((index & 0x55555555) << 1) | ((index & 0xaaaaaaaa) >> 1);
    union Result
    {
        unsigned u;
        float f;
    } result; // Write reversed bits directly into floating-point mantissa.
    result.u = 0x3f800000u | (index >> 9);
    return result.f - 1.f;
}

inline float Halton_sampler::halton3(const unsigned index) const
{
    return (m_perm3[index % 243u] * 14348907u +
            m_perm3[(index / 243u) % 243u] * 59049u +
            m_perm3[(index / 59049u) % 243u] * 243u +
            m_perm3[(index / 14348907u) % 243u]) * float(0x1.fffffcp-1 / 3486784401u); // Results in [0,1).
}

inline float Halton_sampler::halton5(const unsigned index) const
{
    return (m_perm5[index % 125u] * 1953125u +
            m_perm5[(index / 125u) % 125u] * 15625u +
            m_perm5[(index / 15625u) % 125u] * 125u +
            m_perm5[(index / 1953125u) % 125u]) * float(0x1.fffffcp-1 / 244140625u); // Results in [0,1).
}

#endif // HALTON_SAMPLER_H

